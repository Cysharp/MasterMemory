<#@ template debug="false" hostspecific="false" linePragmas="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated />
#pragma warning disable CS0105
<#= Using #>

namespace <#= Namespace #>.Tables
{
   public sealed partial class <#= GenerationContext.ClassName #>Table : TableBase<<#= GenerationContext.ClassName #>>, ITableUniqueValidate
   {
        public Func<<#= GenerationContext.ClassName #>, <#= GenerationContext.PrimaryKey.BuildTypeName() #>> PrimaryKeySelector => <#= GenerationContext.PrimaryKey.SelectorName #>;
        readonly Func<<#= GenerationContext.ClassName #>, <#= GenerationContext.PrimaryKey.BuildTypeName() #>> <#= GenerationContext.PrimaryKey.SelectorName #>;

<# for(var i = 0; i < GenerationContext.SecondaryKeys.Length; i++) { var item = GenerationContext.SecondaryKeys[i]; #>
        readonly <#= GenerationContext.ClassName #>[] <#= item.TableName #>;
        readonly Func<<#= GenerationContext.ClassName #>, <#= item.BuildTypeName() #>> <#= item.SelectorName #>;
<# } #>

        public <#= GenerationContext.ClassName #>Table(<#= GenerationContext.ClassName #>[] sortedData)
            : base(sortedData)
        {
            this.<#= GenerationContext.PrimaryKey.SelectorName #> = x => <#= GenerationContext.PrimaryKey.BuildKeyAccessor("x") #>;
<# for(var i = 0; i < GenerationContext.SecondaryKeys.Length; i++) { var item = GenerationContext.SecondaryKeys[i]; #>
            this.<#= item.SelectorName #> = x => <#= item.BuildKeyAccessor("x") #>;
            this.<#= item.TableName #> = CloneAndSortBy(this.secondaryIndex<#= item.IndexNo #>Selector, <#= item.BuildComparer() #>);
<# } #>
            OnAfterConstruct();
        }

        partial void OnAfterConstruct();

<# for(var i = 0; i < GenerationContext.SecondaryKeys.Length; i++) { var item = GenerationContext.SecondaryKeys[i]; #>
        public RangeView<<#= GenerationContext.ClassName #>> SortBy<#= item.BuildMethodName() #> => new RangeView<<#= GenerationContext.ClassName #>>(<#= item.TableName #>, 0, <#= item.TableName #>.Length - 1, true);
<# } #>

<# foreach(var item in new KeyBase[] { GenerationContext.PrimaryKey }.Concat(GenerationContext.SecondaryKeys)) { #>
<# if(item.CanInlineBinarySearch) { #>
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public <#= item.BuildReturnTypeName(GenerationContext.ClassName) #> FindBy<#= item.BuildMethodName() #>(<#= item.BuildTypeName() #> key)
        {
            var lo = 0;
            var hi = data.Length - 1;
            while (lo <= hi)
            {
                var mid = (int)(((uint)hi + (uint)lo) >> 1);
                var selected = data[mid].<#= item.Properties[0].Name #>;
                var found = (selected < key) ? -1 : (selected > key) ? 1 : 0;
                if (found == 0) { return data[mid]; }
                if (found < 0) { lo = mid + 1; }
                else { hi = mid - 1; }
            }
<# if(ThrowKeyIfNotFound) { #>
            return ThrowKeyNotFound(key);
<# } else { #>
            return default;
<# } #>
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public bool TryFindBy<#= item.BuildMethodName() #>(<#= item.BuildTypeName() #> key, out <#= item.BuildReturnTypeName(GenerationContext.ClassName) #> result)
        {
            var lo = 0;
            var hi = data.Length - 1;
            while (lo <= hi)
            {
                var mid = (int)(((uint)hi + (uint)lo) >> 1);
                var selected = data[mid].<#= item.Properties[0].Name #>;
                var found = (selected < key) ? -1 : (selected > key) ? 1 : 0;
                if (found == 0) { result = data[mid]; return true; }
                if (found < 0) { lo = mid + 1; }
                else { hi = mid - 1; }
            }
            result = default;
            return false;
        }
<# } else { #>
<# if (!item.IsNonUnique) { #>
        public <#= item.BuildReturnTypeName(GenerationContext.ClassName) #> FindBy<#= item.BuildMethodName() #>(<#= item.BuildTypeName() #> key)
        {
            return <#= item.BuildFindPrefix() #>Core<#= !item.IsNonUnique && item.IsIntType ? "Int" : "" #>(<#= item.TableName #>, <#= item.SelectorName #>, <#= item.BuildComparer() #>, key, <#= ThrowKeyIfNotFound.ToString().ToLower() #>);
        }
        
        public bool TryFindBy<#= item.BuildMethodName() #>(<#= item.BuildTypeName() #> key, out <#= item.BuildReturnTypeName(GenerationContext.ClassName) #> result)
        {
            return Try<#= item.BuildFindPrefix() #>Core<#= !item.IsNonUnique && item.IsIntType ? "Int" : "" #>(<#= item.TableName #>, <#= item.SelectorName #>, <#= item.BuildComparer() #>, key, out result);
        }
<# } else { #>
        public <#= item.BuildReturnTypeName(GenerationContext.ClassName) #> FindBy<#= item.BuildMethodName() #>(<#= item.BuildTypeName() #> key)
        {
            return <#= item.BuildFindPrefix() #>Core<#= !item.IsNonUnique && item.IsIntType ? "Int" : "" #>(<#= item.TableName #>, <#= item.SelectorName #>, <#= item.BuildComparer() #>, key);
        }
<# } #>
<# } #>

        public <#= item.BuildReturnTypeName(GenerationContext.ClassName) #> FindClosestBy<#= item.BuildMethodName() #>(<#= item.BuildTypeName() #> key, bool selectLower = true)
        {
            return <#= item.BuildFindPrefix() #>ClosestCore(<#= item.TableName #>, <#= item.SelectorName #>, <#= item.BuildComparer() #>, key, selectLower);
        }

        public RangeView<<#= GenerationContext.ClassName #>> FindRangeBy<#= item.BuildMethodName() #>(<#= item.BuildTypeName() #> min, <#= item.BuildTypeName() #> max, bool ascendant = true)
        {
            return <#= item.BuildFindPrefix() #>RangeCore(<#= item.TableName #>, <#= item.SelectorName #>, <#= item.BuildComparer() #>, min, max, ascendant);
        }

<# } #>

        void ITableUniqueValidate.ValidateUnique(ValidateResult resultSet)
        {
#if !DISABLE_MASTERMEMORY_VALIDATOR

<# if (!GenerationContext.PrimaryKey.IsNonUnique) { var key = GenerationContext.PrimaryKey; #>
            ValidateUniqueCore(<#= key.TableName #>, <#= key.SelectorName #>, "<#= key.BuildPropertyTupleName() #>", resultSet);       
<# } #>
<# for(var i = 0; i < GenerationContext.SecondaryKeys.Length; i++) { var key = GenerationContext.SecondaryKeys[i]; #>
<#      if (!key.IsNonUnique) { #>
            ValidateUniqueCore(<#= key.TableName #>, <#= key.SelectorName #>, "<#= key.BuildPropertyTupleName() #>", resultSet);       
<#      } #>
<# } #>

#endif
        }

#if !DISABLE_MASTERMEMORY_METADATABASE

        public static MasterMemory.Meta.MetaTable CreateMetaTable()
        {
            return new MasterMemory.Meta.MetaTable(typeof(<#= GenerationContext.ClassName #>), typeof(<#= GenerationContext.ClassName #>Table), "<#= GenerationContext.MemoryTableName #>",
                new MasterMemory.Meta.MetaProperty[]
                {
<# foreach(var prop in GenerationContext.Properties) { #>
                    new MasterMemory.Meta.MetaProperty(typeof(<#= GenerationContext.ClassName #>).GetProperty("<#= prop.Name #>")),
<# } #>
                },
                new MasterMemory.Meta.MetaIndex[]{
<# foreach(var key in GenerationContext.Keys) { #>
                    new MasterMemory.Meta.MetaIndex(new System.Reflection.PropertyInfo[] {
<# foreach(var keyProp in key.Properties) { #>
                        typeof(<#= GenerationContext.ClassName #>).GetProperty("<#= keyProp.Name #>"),
<# } #>
                    }, <#= key.IsPrimary.ToString().ToLower() #>, <#= (!key.IsNonUnique).ToString().ToLower() #>, <#= key.BuildComparer() #>),
<# } #>
                });
        }

#endif
    }
}